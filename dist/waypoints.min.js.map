{"version":3,"sources":["webpack:///waypoints.min.js","webpack:///webpack/bootstrap 368ac1a6edec2f715a09","webpack:///./source/index.js","webpack:///./source/dom.js","webpack:///./source/context.js","webpack:///./source/group.js","webpack:///./source/waypoint.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","DOM","Context","Group","Waypoint","oldWindowLoad","window","onload","findOrCreateByElement","refreshAll","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","element","this","handlers","isWindow","ownerDocument","defaultView","innerHeight","document","documentElement","clientHeight","innerWidth","clientWidth","includeMargin","height","computedStyle","getComputedStyle","parseInt","marginTop","marginBottom","width","marginLeft","marginRight","event","handler","_event$split","split","_event$split2","eventType","_event$split2$","namespace","nsHandlers","nsTypeList","addEventListener","_event$split3","_event$split4","removeListeners","ns","type","listeners","_this","forEach","listener","removeEventListener","rect","getBoundingClientRect","top","pageYOffset","clientTop","left","pageXOffset","clientLeft","isEmptyObject","obj","requestAnimationFrameShim","callback","setTimeout","keyCounter","contexts","reqAnimationFrame","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","bind","dom","didScroll","didResize","oldScroll","x","scrollLeft","y","scrollTop","waypoints","vertical","horizontal","waypointContextKey","createThrottledScrollHandler","createThrottledResizeHandler","scrollHandler","handleScroll","on","_this2","resizeHandler","handleResize","triggeredGroups","axes","newScroll","axisKey","axis","waypointKey","waypoint","direction","shouldScrollTrigger","group","queueTrigger","groupKey","flushTriggers","refresh","horizontalEmpty","verticalEmpty","off","destroy","contextOffset","offset","contextScroll","contextDimension","refreshTriggerPoint","contextAdjustment","findByElement","contextId","byTriggerPoint","a","b","triggerPoint","byReverseTriggerPoint","groups","_ref","name","clearTriggerQueues","index","indexOf","splice","triggerQueues","up","down","right","_loop","reverse","sort","continuous","trigger","options","_extends","assign","arguments","source","hasOwnProperty","allWaypoints","axialDirections","backward","forward","Error","mergeOptions","enabled","findOrCreate","context","add","offsetAliases","defaults","remove","previous","wasBeforeTriggerPoint","nowAfterTriggerPoint","axialDirection","elementOffset","adjustment","oldTriggerPoint","offsetProp","apply","parseFloat","Math","ceil","floor","shouldRefreshTrigger","scrollProp","wasBeforeScroll","nowAfterScroll","triggeredBackward","triggeredForward","freshWaypoint","method","invokeAll","get","bottom-in-view","outerHeight","right-in-view","outerWidth"],"mappings":"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","file":"waypoints.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar DOM = __webpack_require__(1)();\n\tvar Context = __webpack_require__(2)(DOM);\n\tvar Group = __webpack_require__(3)();\n\tvar Waypoint = __webpack_require__(4)(DOM, Context, Group);\n\tvar oldWindowLoad = window.onload;\n\t\n\tContext.findOrCreateByElement(window);\n\t\n\twindow.onload = function () {\n\t  if (oldWindowLoad) {\n\t    oldWindowLoad();\n\t  }\n\t  Context.refreshAll();\n\t};\n\t\n\twindow.Waypoint = Waypoint;\n\tmodule.exports = Waypoint;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function () {\n\t  return function () {\n\t    function DOM(element) {\n\t      _classCallCheck(this, DOM);\n\t\n\t      this.element = element;\n\t      this.handlers = {};\n\t      this.isWindow = element.window === element;\n\t      this.window = this.isWindow ? element : element.ownerDocument.defaultView;\n\t    }\n\t\n\t    _createClass(DOM, [{\n\t      key: 'innerHeight',\n\t      value: function innerHeight() {\n\t        if (this.isWindow) {\n\t          return this.element.innerHeight || document.documentElement.clientHeight;\n\t        }\n\t        return this.element.clientHeight;\n\t      }\n\t    }, {\n\t      key: 'innerWidth',\n\t      value: function innerWidth() {\n\t        if (this.isWindow) {\n\t          return this.innerWidth;\n\t        }\n\t        return this.element.clientWidth;\n\t      }\n\t    }, {\n\t      key: 'outerHeight',\n\t      value: function outerHeight(includeMargin) {\n\t        var height = this.innerHeight();\n\t\n\t        if (includeMargin && !this.isWindow) {\n\t          var computedStyle = window.getComputedStyle(this.element);\n\t          height += parseInt(computedStyle.marginTop, 10);\n\t          height += parseInt(computedStyle.marginBottom, 10);\n\t        }\n\t\n\t        return height;\n\t      }\n\t    }, {\n\t      key: 'outerWidth',\n\t      value: function outerWidth(includeMargin) {\n\t        var width = this.innerWidth();\n\t\n\t        if (includeMargin && !this.isWindow) {\n\t          var computedStyle = window.getComputedStyle(this.element);\n\t          width += parseInt(computedStyle.marginLeft, 10);\n\t          width += parseInt(computedStyle.marginRight, 10);\n\t        }\n\t\n\t        return width;\n\t      }\n\t    }, {\n\t      key: 'scrollLeft',\n\t      value: function scrollLeft() {\n\t        return this.element[this.isWindow ? 'pageXOffset' : 'scrollLeft'];\n\t      }\n\t    }, {\n\t      key: 'scrollTop',\n\t      value: function scrollTop() {\n\t        return this.element[this.isWindow ? 'pageYOffset' : 'scrollTop'];\n\t      }\n\t    }, {\n\t      key: 'on',\n\t      value: function on(event, handler) {\n\t        var _event$split = event.split('.'),\n\t            _event$split2 = _slicedToArray(_event$split, 2),\n\t            eventType = _event$split2[0],\n\t            _event$split2$ = _event$split2[1],\n\t            namespace = _event$split2$ === undefined ? '__default' : _event$split2$;\n\t\n\t        var nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {};\n\t        var nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || [];\n\t\n\t        nsTypeList.push(handler);\n\t        this.element.addEventListener(eventType, handler);\n\t      }\n\t    }, {\n\t      key: 'off',\n\t      value: function off(event, handler) {\n\t        var _event$split3 = event.split('.'),\n\t            _event$split4 = _slicedToArray(_event$split3, 2),\n\t            eventType = _event$split4[0],\n\t            namespace = _event$split4[1];\n\t\n\t        if (namespace && this.handlers[namespace] && eventType) {\n\t          this.removeListeners(this.handlers[namespace][eventType], handler);\n\t          this.handlers[namespace][eventType] = [];\n\t        } else if (eventType) {\n\t          for (var ns in this.handlers) {\n\t            this.removeListeners(this.handlers[ns][eventType] || [], handler);\n\t            this.handlers[ns][eventType] = [];\n\t          }\n\t        } else if (namespace && this.handlers[namespace]) {\n\t          for (var type in this.handlers[namespace]) {\n\t            this.removeListeners(this.handlers[namespace][type], handler);\n\t          }\n\t          this.handlers[namespace] = {};\n\t        }\n\t      }\n\t    }, {\n\t      key: 'removeListeners',\n\t      value: function removeListeners(listeners, handler) {\n\t        var _this = this;\n\t\n\t        listeners.forEach(function (listener) {\n\t          if (!handler || handler === listener) {\n\t            _this.element.removeEventListener(listener);\n\t          }\n\t        });\n\t      }\n\t\n\t      /* Adapted from jQuery 1.x offset() */\n\t\n\t    }, {\n\t      key: 'offset',\n\t      value: function offset() {\n\t        if (!this.element.ownerDocument) {\n\t          return null;\n\t        }\n\t\n\t        var documentElement = this.element.ownerDocument.documentElement;\n\t        var rect = this.element.getBoundingClientRect();\n\t\n\t        return {\n\t          top: rect.top + this.window.pageYOffset - documentElement.clientTop,\n\t          left: rect.left + this.window.pageXOffset - documentElement.clientLeft\n\t        };\n\t      }\n\t    }], [{\n\t      key: 'viewportHeight',\n\t      value: function viewportHeight() {\n\t        return window.innerHeight || document.documentElement.clientHeight;\n\t      }\n\t    }, {\n\t      key: 'viewportWidth',\n\t      value: function viewportWidth() {\n\t        return document.documentElement.clientWidth;\n\t      }\n\t    }]);\n\t\n\t    return DOM;\n\t  }();\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction isEmptyObject(obj) {\n\t  for (var key in obj) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\t\n\tmodule.exports = function (DOM) {\n\t  var keyCounter = 0;\n\t  var contexts = {};\n\t  var reqAnimationFrame = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || requestAnimationFrameShim).bind(window);\n\t\n\t  function requestAnimationFrameShim(callback) {\n\t    window.setTimeout(callback, 1000 / 60);\n\t  }\n\t\n\t  return function () {\n\t    function Context(element) {\n\t      _classCallCheck(this, Context);\n\t\n\t      this.element = element;\n\t      this.dom = new DOM(element);\n\t      this.key = 'context-' + keyCounter;\n\t      this.didScroll = false;\n\t      this.didResize = false;\n\t      this.oldScroll = {\n\t        x: this.dom.scrollLeft(),\n\t        y: this.dom.scrollTop()\n\t      };\n\t      this.waypoints = {\n\t        vertical: {},\n\t        horizontal: {}\n\t      };\n\t\n\t      element.waypointContextKey = this.key;\n\t      contexts[element.waypointContextKey] = this;\n\t      keyCounter += 1;\n\t\n\t      this.createThrottledScrollHandler();\n\t      if (this.dom.isWindow) {\n\t        this.createThrottledResizeHandler();\n\t      }\n\t    }\n\t\n\t    _createClass(Context, [{\n\t      key: 'createThrottledScrollHandler',\n\t      value: function createThrottledScrollHandler() {\n\t        var _this = this;\n\t\n\t        var scrollHandler = function scrollHandler() {\n\t          _this.handleScroll();\n\t          _this.didScroll = false;\n\t        };\n\t\n\t        this.dom.on('scroll.waypoints', function () {\n\t          if (!_this.didScroll) {\n\t            _this.didScroll = true;\n\t            reqAnimationFrame(scrollHandler);\n\t          }\n\t        });\n\t      }\n\t    }, {\n\t      key: 'createThrottledResizeHandler',\n\t      value: function createThrottledResizeHandler() {\n\t        var _this2 = this;\n\t\n\t        var resizeHandler = function resizeHandler() {\n\t          _this2.handleResize();\n\t          _this2.didResize = false;\n\t        };\n\t\n\t        this.dom.on('resize.waypoints', function () {\n\t          if (!_this2.didResize) {\n\t            _this2.didResize = true;\n\t            reqAnimationFrame(resizeHandler);\n\t          }\n\t        });\n\t      }\n\t    }, {\n\t      key: 'handleResize',\n\t      value: function handleResize() {\n\t        Context.refreshAll();\n\t      }\n\t    }, {\n\t      key: 'handleScroll',\n\t      value: function handleScroll() {\n\t        var triggeredGroups = {};\n\t        var axes = {\n\t          horizontal: {\n\t            newScroll: this.dom.scrollLeft(),\n\t            oldScroll: this.oldScroll.x\n\t          },\n\t          vertical: {\n\t            newScroll: this.dom.scrollTop(),\n\t            oldScroll: this.oldScroll.y\n\t          }\n\t        };\n\t\n\t        for (var axisKey in axes) {\n\t          var axis = axes[axisKey];\n\t\n\t          for (var waypointKey in this.waypoints[axisKey]) {\n\t            var waypoint = this.waypoints[axisKey][waypointKey];\n\t            var direction = waypoint.shouldScrollTrigger(axis.oldScroll, axis.newScroll);\n\t            if (direction) {\n\t              waypoint.group.queueTrigger(waypoint, direction);\n\t              triggeredGroups[waypoint.group.id] = waypoint.group;\n\t            }\n\t          }\n\t        }\n\t\n\t        for (var groupKey in triggeredGroups) {\n\t          triggeredGroups[groupKey].flushTriggers();\n\t        }\n\t\n\t        this.oldScroll = {\n\t          x: axes.horizontal.newScroll,\n\t          y: axes.vertical.newScroll\n\t        };\n\t      }\n\t    }, {\n\t      key: 'add',\n\t      value: function add(waypoint) {\n\t        this.waypoints[waypoint.axis][waypoint.key] = waypoint;\n\t        this.refresh();\n\t      }\n\t    }, {\n\t      key: 'remove',\n\t      value: function remove(waypoint) {\n\t        delete this.waypoints[waypoint.axis][waypoint.key];\n\t\n\t        var horizontalEmpty = isEmptyObject(this.waypoints.horizontal);\n\t        var verticalEmpty = isEmptyObject(this.waypoints.vertical);\n\t\n\t        if (horizontalEmpty && verticalEmpty && !this.dom.isWindow) {\n\t          this.dom.off('.waypoints');\n\t          delete contexts[this.key];\n\t        }\n\t      }\n\t    }, {\n\t      key: 'destroy',\n\t      value: function destroy() {\n\t        for (var axis in this.waypoints) {\n\t          for (var waypointKey in this.waypoints[axis]) {\n\t            this.waypoints[axis][waypointKey].destroy();\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refresh',\n\t      value: function refresh() {\n\t        this.handleScroll();\n\t\n\t        var contextOffset = this.dom.offset() || { left: 0, top: 0 };\n\t        var triggeredGroups = {};\n\t        var axes = {\n\t          horizontal: {\n\t            contextOffset: contextOffset.left,\n\t            contextScroll: this.dom.isWindow ? 0 : this.oldScroll.x,\n\t            contextDimension: this.dom.innerWidth()\n\t          },\n\t          vertical: {\n\t            contextOffset: contextOffset.top,\n\t            contextScroll: this.dom.isWindow ? 0 : this.oldScroll.y,\n\t            contextDimension: this.dom.innerHeight()\n\t          }\n\t        };\n\t\n\t        for (var axisKey in axes) {\n\t          var axis = axes[axisKey];\n\t          for (var waypointKey in this.waypoints[axisKey]) {\n\t            var waypoint = this.waypoints[axisKey][waypointKey];\n\t            var direction = waypoint.refreshTriggerPoint({\n\t              contextDimension: axis.contextDimension,\n\t              contextAdjustment: axis.contextScroll - axis.contextOffset\n\t            });\n\t\n\t            if (direction) {\n\t              waypoint.group.queueTrigger(waypoint, direction);\n\t              triggeredGroups[waypoint.group.id] = waypoint.group;\n\t            }\n\t          }\n\t        }\n\t\n\t        reqAnimationFrame(function () {\n\t          for (var groupKey in triggeredGroups) {\n\t            triggeredGroups[groupKey].flushTriggers();\n\t          }\n\t        });\n\t\n\t        return this;\n\t      }\n\t    }], [{\n\t      key: 'findOrCreateByElement',\n\t      value: function findOrCreateByElement(element) {\n\t        return Context.findByElement(element) || new Context(element);\n\t      }\n\t    }, {\n\t      key: 'findByElement',\n\t      value: function findByElement(element) {\n\t        return contexts[element.waypointContextKey];\n\t      }\n\t    }, {\n\t      key: 'refreshAll',\n\t      value: function refreshAll() {\n\t        for (var contextId in contexts) {\n\t          contexts[contextId].refresh();\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return Context;\n\t  }();\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function () {\n\t  function byTriggerPoint(a, b) {\n\t    return a.triggerPoint - b.triggerPoint;\n\t  }\n\t\n\t  function byReverseTriggerPoint(a, b) {\n\t    return b.triggerPoint - a.triggerPoint;\n\t  }\n\t\n\t  var groups = {\n\t    vertical: {},\n\t    horizontal: {}\n\t  };\n\t\n\t  return function () {\n\t    function Group(_ref) {\n\t      var axis = _ref.axis,\n\t          name = _ref.name;\n\t\n\t      _classCallCheck(this, Group);\n\t\n\t      this.name = name;\n\t      this.axis = axis;\n\t      this.id = name + '-' + axis;\n\t      this.waypoints = [];\n\t      this.clearTriggerQueues();\n\t      groups[axis][name] = this;\n\t    }\n\t\n\t    _createClass(Group, [{\n\t      key: 'add',\n\t      value: function add(waypoint) {\n\t        this.waypoints.push(waypoint);\n\t      }\n\t    }, {\n\t      key: 'remove',\n\t      value: function remove(waypoint) {\n\t        var index = this.waypoints.indexOf(waypoint);\n\t        if (index > -1) {\n\t          this.waypoints.splice(index, 1);\n\t        }\n\t      }\n\t    }, {\n\t      key: 'clearTriggerQueues',\n\t      value: function clearTriggerQueues() {\n\t        this.triggerQueues = {\n\t          up: [],\n\t          down: [],\n\t          left: [],\n\t          right: []\n\t        };\n\t      }\n\t    }, {\n\t      key: 'queueTrigger',\n\t      value: function queueTrigger(waypoint, direction) {\n\t        this.triggerQueues[direction].push(waypoint);\n\t      }\n\t    }, {\n\t      key: 'flushTriggers',\n\t      value: function flushTriggers() {\n\t        var _this = this;\n\t\n\t        var _loop = function _loop() {\n\t          var waypoints = _this.triggerQueues[direction];\n\t          var reverse = direction === 'up' || direction === 'left';\n\t          waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);\n\t          waypoints.forEach(function (waypoint, i) {\n\t            if (waypoint.continuous || i === waypoints.length - 1) {\n\t              waypoint.trigger(direction);\n\t            }\n\t          });\n\t        };\n\t\n\t        for (var direction in this.triggerQueues) {\n\t          _loop();\n\t        }\n\t        this.clearTriggerQueues();\n\t      }\n\t    }, {\n\t      key: 'next',\n\t      value: function next(waypoint) {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        var index = this.waypoints.indexOf(waypoint);\n\t        if (index === -1 || index === this.waypoints.length - 1) {\n\t          return null;\n\t        }\n\t        return this.waypoints[index + 1];\n\t      }\n\t    }, {\n\t      key: 'previous',\n\t      value: function previous(waypoint) {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        var index = this.waypoints.indexOf(waypoint);\n\t        if (index === -1 || !index) {\n\t          return null;\n\t        }\n\t        return this.waypoints[index - 1];\n\t      }\n\t    }, {\n\t      key: 'first',\n\t      value: function first() {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        return this.waypoints[0];\n\t      }\n\t    }, {\n\t      key: 'last',\n\t      value: function last() {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        return this.waypoints[this.waypoints.length - 1];\n\t      }\n\t    }], [{\n\t      key: 'findOrCreate',\n\t      value: function findOrCreate(options) {\n\t        return groups[options.axis][options.name] || new Group(options);\n\t      }\n\t    }]);\n\t\n\t    return Group;\n\t  }();\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function (DOM, Context, Group) {\n\t  var keyCounter = 0;\n\t  var allWaypoints = {};\n\t  var axialDirections = {\n\t    horizontal: {\n\t      backward: 'left',\n\t      forward: 'right'\n\t    },\n\t    vertical: {\n\t      backward: 'up',\n\t      forward: 'down'\n\t    }\n\t  };\n\t\n\t  return function () {\n\t    function Waypoint(options) {\n\t      _classCallCheck(this, Waypoint);\n\t\n\t      if (!options) {\n\t        throw new Error('No options passed to Waypoint constructor');\n\t      }\n\t      if (!options.element) {\n\t        throw new Error('No element option passed to Waypoint constructor');\n\t      }\n\t      if (!options.handler) {\n\t        throw new Error('No handler option passed to Waypoint constructor');\n\t      }\n\t\n\t      options = this.mergeOptions(options);\n\t      this.key = 'waypoint-' + keyCounter;\n\t      this.element = options.element;\n\t      this.dom = new DOM(options.element);\n\t      this.callback = options.handler;\n\t      this.axis = options.horizontal ? 'horizontal' : 'vertical';\n\t      this.enabled = options.enabled;\n\t      this.continuous = options.continuous;\n\t      this.offset = options.offset;\n\t      this.triggerPoint = null;\n\t      this.group = Group.findOrCreate({\n\t        name: options.group,\n\t        axis: this.axis\n\t      });\n\t      this.context = Context.findOrCreateByElement(options.context);\n\t\n\t      this.group.add(this);\n\t      this.context.add(this);\n\t      allWaypoints[this.key] = this;\n\t      keyCounter += 1;\n\t    }\n\t\n\t    _createClass(Waypoint, [{\n\t      key: 'mergeOptions',\n\t      value: function mergeOptions(options) {\n\t        if (Waypoint.offsetAliases[options.offset]) {\n\t          options.offset = Waypoint.offsetAliases[options.offset];\n\t        }\n\t        return _extends({}, Waypoint.defaults, options);\n\t      }\n\t    }, {\n\t      key: 'destroy',\n\t      value: function destroy() {\n\t        this.context.remove(this);\n\t        this.group.remove(this);\n\t        delete allWaypoints[this.key];\n\t      }\n\t    }, {\n\t      key: 'disable',\n\t      value: function disable() {\n\t        this.enabled = false;\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'enable',\n\t      value: function enable() {\n\t        this.context.refresh();\n\t        this.enabled = true;\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'next',\n\t      value: function next() {\n\t        return this.group.next(this);\n\t      }\n\t    }, {\n\t      key: 'previous',\n\t      value: function previous() {\n\t        return this.group.previous(this);\n\t      }\n\t    }, {\n\t      key: 'trigger',\n\t      value: function trigger(direction) {\n\t        if (this.enabled) {\n\t          this.callback.call(this, direction);\n\t        }\n\t      }\n\t    }, {\n\t      key: 'shouldScrollTrigger',\n\t      value: function shouldScrollTrigger(oldScroll, newScroll) {\n\t        if (this.triggerPoint === null) {\n\t          return null;\n\t        }\n\t\n\t        var wasBeforeTriggerPoint = oldScroll < this.triggerPoint;\n\t        var nowAfterTriggerPoint = newScroll >= this.triggerPoint;\n\t\n\t        if (wasBeforeTriggerPoint && nowAfterTriggerPoint) {\n\t          return this.axialDirection('forward');\n\t        } else if (!wasBeforeTriggerPoint && !nowAfterTriggerPoint) {\n\t          return this.axialDirection('backward');\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refreshTriggerPoint',\n\t      value: function refreshTriggerPoint(_ref) {\n\t        var contextDimension = _ref.contextDimension,\n\t            contextAdjustment = _ref.contextAdjustment;\n\t\n\t        var elementOffset = 0;\n\t        var adjustment = this.offset;\n\t        var oldTriggerPoint = this.triggerPoint;\n\t\n\t        if (!this.dom.isWindow) {\n\t          var offsetProp = this.axis === 'vertical' ? 'top' : 'left';\n\t          elementOffset = this.dom.offset()[offsetProp];\n\t        }\n\t\n\t        if (typeof this.offset === 'function') {\n\t          adjustment = this.offset.apply(this);\n\t        } else if (typeof this.offset === 'string') {\n\t          adjustment = parseFloat(adjustment);\n\t          if (this.offset.indexOf('%') > -1) {\n\t            adjustment = Math.ceil(contextDimension * adjustment / 100);\n\t          }\n\t        }\n\t\n\t        this.triggerPoint = Math.floor(elementOffset + contextAdjustment - adjustment);\n\t        return this.shouldRefreshTrigger(oldTriggerPoint);\n\t      }\n\t    }, {\n\t      key: 'shouldRefreshTrigger',\n\t      value: function shouldRefreshTrigger(oldTriggerPoint) {\n\t        var scrollProp = this.axis === 'vertical' ? 'y' : 'x';\n\t        var contextScroll = this.context.oldScroll[scrollProp];\n\t        var wasBeforeScroll = oldTriggerPoint < contextScroll;\n\t        var nowAfterScroll = this.triggerPoint >= contextScroll;\n\t        var triggeredBackward = wasBeforeScroll && nowAfterScroll;\n\t        var triggeredForward = !wasBeforeScroll && !nowAfterScroll;\n\t        var freshWaypoint = oldTriggerPoint === null;\n\t\n\t        if (!freshWaypoint && triggeredBackward) {\n\t          return this.axialDirection('backward');\n\t        } else if (!freshWaypoint && triggeredForward) {\n\t          return this.axialDirection('forward');\n\t        } else if (freshWaypoint && contextScroll >= this.triggerPoint) {\n\t          return this.axialDirection('forward');\n\t        }\n\t      }\n\t    }, {\n\t      key: 'axialDirection',\n\t      value: function axialDirection(direction) {\n\t        return axialDirections[this.axis][direction];\n\t      }\n\t    }], [{\n\t      key: 'invokeAll',\n\t      value: function invokeAll(method) {\n\t        for (var waypointKey in allWaypoints) {\n\t          allWaypoints[waypointKey][method]();\n\t        }\n\t      }\n\t    }, {\n\t      key: 'destroyAll',\n\t      value: function destroyAll() {\n\t        this.invokeAll('destroy');\n\t      }\n\t    }, {\n\t      key: 'disableAll',\n\t      value: function disableAll() {\n\t        this.invokeAll('disable');\n\t      }\n\t    }, {\n\t      key: 'enableAll',\n\t      value: function enableAll() {\n\t        Context.refreshAll();\n\t        for (var waypointKey in allWaypoints) {\n\t          allWaypoints[waypointKey].enabled = true;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refreshAll',\n\t      value: function refreshAll() {\n\t        Context.refreshAll();\n\t      }\n\t    }, {\n\t      key: 'viewportHeight',\n\t      value: function viewportHeight() {\n\t        return new DOM(window).innerHeight();\n\t      }\n\t    }, {\n\t      key: 'viewportWidth',\n\t      value: function viewportWidth() {\n\t        return new DOM(window).innerWidth();\n\t      }\n\t    }, {\n\t      key: 'offsetAliases',\n\t      get: function get() {\n\t        return {\n\t          'bottom-in-view': function bottomInView() {\n\t            return this.context.dom.innerHeight() - this.dom.outerHeight();\n\t          },\n\t          'right-in-view': function rightInView() {\n\t            return this.context.dom.innerWidth() - this.dom.outerWidth();\n\t          }\n\t        };\n\t      }\n\t    }, {\n\t      key: 'defaults',\n\t      get: function get() {\n\t        return {\n\t          context: window,\n\t          continuous: true,\n\t          enabled: true,\n\t          group: 'default',\n\t          horizontal: false,\n\t          offset: 0\n\t        };\n\t      }\n\t    }]);\n\t\n\t    return Waypoint;\n\t  }();\n\t};\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// waypoints.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 368ac1a6edec2f715a09","var DOM = require('./dom')()\nvar Context = require('./context')(DOM)\nvar Group = require('./group')()\nvar Waypoint = require('./waypoint')(DOM, Context, Group)\nvar oldWindowLoad = window.onload\n\nContext.findOrCreateByElement(window)\n\nwindow.onload = function () {\n  if (oldWindowLoad) {\n    oldWindowLoad()\n  }\n  Context.refreshAll()\n}\n\nwindow.Waypoint = Waypoint\nmodule.exports = Waypoint\n\n\n\n// WEBPACK FOOTER //\n// ./source/index.js","module.exports = function () {\n  return class DOM {\n    constructor (element) {\n      this.element = element\n      this.handlers = {}\n      this.isWindow = element.window === element\n      this.window = this.isWindow ? element : element.ownerDocument.defaultView\n    }\n\n    innerHeight () {\n      if (this.isWindow) {\n        return this.element.innerHeight || document.documentElement.clientHeight\n      }\n      return this.element.clientHeight\n    }\n\n    innerWidth () {\n      if (this.isWindow) {\n        return this.innerWidth\n      }\n      return this.element.clientWidth\n    }\n\n    outerHeight (includeMargin) {\n      var height = this.innerHeight()\n\n      if (includeMargin && !this.isWindow) {\n        let computedStyle = window.getComputedStyle(this.element)\n        height += parseInt(computedStyle.marginTop, 10)\n        height += parseInt(computedStyle.marginBottom, 10)\n      }\n\n      return height\n    }\n\n    outerWidth (includeMargin) {\n      var width = this.innerWidth()\n\n      if (includeMargin && !this.isWindow) {\n        let computedStyle = window.getComputedStyle(this.element)\n        width += parseInt(computedStyle.marginLeft, 10)\n        width += parseInt(computedStyle.marginRight, 10)\n      }\n\n      return width\n    }\n\n    scrollLeft () {\n      return this.element[this.isWindow ? 'pageXOffset' : 'scrollLeft']\n    }\n\n    scrollTop () {\n      return this.element[this.isWindow ? 'pageYOffset' : 'scrollTop']\n    }\n\n    on (event, handler) {\n      const [eventType, namespace='__default'] = event.split('.')\n      const nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {}\n      const nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || []\n\n      nsTypeList.push(handler)\n      this.element.addEventListener(eventType, handler)\n    }\n\n    off (event, handler) {\n      const [eventType, namespace] = event.split('.')\n\n      if (namespace && this.handlers[namespace] && eventType) {\n        this.removeListeners(this.handlers[namespace][eventType], handler)\n        this.handlers[namespace][eventType] = []\n      } else if (eventType) {\n        for (var ns in this.handlers) {\n          this.removeListeners(this.handlers[ns][eventType] || [], handler)\n          this.handlers[ns][eventType] = []\n        }\n      } else if (namespace && this.handlers[namespace]) {\n        for (var type in this.handlers[namespace]) {\n          this.removeListeners(this.handlers[namespace][type], handler)\n        }\n        this.handlers[namespace] = {}\n      }\n    }\n\n    removeListeners (listeners, handler) {\n      listeners.forEach((listener) => {\n        if (!handler || handler === listener) {\n          this.element.removeEventListener(listener)\n        }\n      })\n    }\n\n    /* Adapted from jQuery 1.x offset() */\n    offset () {\n      if (!this.element.ownerDocument) {\n        return null\n      }\n\n      const documentElement = this.element.ownerDocument.documentElement\n      const rect = this.element.getBoundingClientRect()\n\n      return {\n        top: rect.top + this.window.pageYOffset - documentElement.clientTop,\n        left: rect.left + this.window.pageXOffset - documentElement.clientLeft\n      }\n    }\n\n    static viewportHeight () {\n      return window.innerHeight || document.documentElement.clientHeight\n    }\n\n    static viewportWidth () {\n      return document.documentElement.clientWidth\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/dom.js","function isEmptyObject (obj) {\n  for (var key in obj) {\n    return false\n  }\n  return true\n}\n\nmodule.exports = function (DOM) {\n  var keyCounter = 0\n  var contexts = {}\n  var reqAnimationFrame = (\n    window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    requestAnimationFrameShim\n  ).bind(window)\n\n  function requestAnimationFrameShim (callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\n  return class Context {\n    constructor (element) {\n      this.element = element\n      this.dom = new DOM(element)\n      this.key = `context-${keyCounter}`\n      this.didScroll = false\n      this.didResize = false\n      this.oldScroll = {\n        x: this.dom.scrollLeft(),\n        y: this.dom.scrollTop()\n      }\n      this.waypoints = {\n        vertical: {},\n        horizontal: {}\n      }\n\n      element.waypointContextKey = this.key\n      contexts[element.waypointContextKey] = this\n      keyCounter += 1\n\n      this.createThrottledScrollHandler()\n      if (this.dom.isWindow) {\n        this.createThrottledResizeHandler()\n      }\n    }\n\n    createThrottledScrollHandler () {\n      const scrollHandler = () => {\n        this.handleScroll()\n        this.didScroll = false\n      }\n\n      this.dom.on('scroll.waypoints', () => {\n        if (!this.didScroll) {\n          this.didScroll = true\n          reqAnimationFrame(scrollHandler)\n        }\n      })\n    }\n\n    createThrottledResizeHandler () {\n      const resizeHandler = () => {\n        this.handleResize()\n        this.didResize = false\n      }\n\n      this.dom.on('resize.waypoints', () => {\n        if (!this.didResize) {\n          this.didResize = true\n          reqAnimationFrame(resizeHandler)\n        }\n      })\n    }\n\n    handleResize () {\n      Context.refreshAll()\n    }\n\n    handleScroll () {\n      var triggeredGroups = {}\n      var axes = {\n        horizontal: {\n          newScroll: this.dom.scrollLeft(),\n          oldScroll: this.oldScroll.x\n        },\n        vertical: {\n          newScroll: this.dom.scrollTop(),\n          oldScroll: this.oldScroll.y\n        }\n      }\n\n      for (var axisKey in axes) {\n        var axis = axes[axisKey]\n\n        for (var waypointKey in this.waypoints[axisKey]) {\n          var waypoint = this.waypoints[axisKey][waypointKey]\n          var direction = waypoint.shouldScrollTrigger(axis.oldScroll, axis.newScroll)\n          if (direction) {\n            waypoint.group.queueTrigger(waypoint, direction)\n            triggeredGroups[waypoint.group.id] = waypoint.group\n          }\n        }\n      }\n\n      for (var groupKey in triggeredGroups) {\n        triggeredGroups[groupKey].flushTriggers()\n      }\n\n      this.oldScroll = {\n        x: axes.horizontal.newScroll,\n        y: axes.vertical.newScroll\n      }\n    }\n\n    add (waypoint) {\n      this.waypoints[waypoint.axis][waypoint.key] = waypoint\n      this.refresh()\n    }\n\n    remove (waypoint) {\n      delete this.waypoints[waypoint.axis][waypoint.key]\n\n      var horizontalEmpty = isEmptyObject(this.waypoints.horizontal)\n      var verticalEmpty = isEmptyObject(this.waypoints.vertical)\n\n      if (horizontalEmpty && verticalEmpty && !this.dom.isWindow) {\n        this.dom.off('.waypoints')\n        delete contexts[this.key]\n      }\n    }\n\n    destroy () {\n      for (var axis in this.waypoints) {\n        for (var waypointKey in this.waypoints[axis]) {\n          this.waypoints[axis][waypointKey].destroy()\n        }\n      }\n    }\n\n    refresh () {\n      this.handleScroll()\n\n      var contextOffset = this.dom.offset() || { left: 0, top: 0 }\n      var triggeredGroups = {}\n      var axes = {\n        horizontal: {\n          contextOffset: contextOffset.left,\n          contextScroll: this.dom.isWindow ? 0 : this.oldScroll.x,\n          contextDimension: this.dom.innerWidth()\n        },\n        vertical: {\n          contextOffset: contextOffset.top,\n          contextScroll: this.dom.isWindow ? 0 : this.oldScroll.y,\n          contextDimension: this.dom.innerHeight()\n        }\n      }\n\n      for (var axisKey in axes) {\n        var axis = axes[axisKey]\n        for (var waypointKey in this.waypoints[axisKey]) {\n          var waypoint = this.waypoints[axisKey][waypointKey]\n          var direction = waypoint.refreshTriggerPoint({\n            contextDimension: axis.contextDimension,\n            contextAdjustment: axis.contextScroll - axis.contextOffset\n          })\n\n          if (direction) {\n            waypoint.group.queueTrigger(waypoint, direction)\n            triggeredGroups[waypoint.group.id] = waypoint.group\n          }\n        }\n      }\n\n      reqAnimationFrame(function() {\n        for (var groupKey in triggeredGroups) {\n          triggeredGroups[groupKey].flushTriggers()\n        }\n      })\n\n      return this\n    }\n\n    static findOrCreateByElement (element) {\n      return Context.findByElement(element) || new Context(element)\n    }\n\n    static findByElement (element) {\n      return contexts[element.waypointContextKey]\n    }\n\n    static refreshAll () {\n      for (var contextId in contexts) {\n        contexts[contextId].refresh()\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/context.js","module.exports = function () {\n  function byTriggerPoint (a, b) {\n    return a.triggerPoint - b.triggerPoint\n  }\n\n  function byReverseTriggerPoint(a, b) {\n    return b.triggerPoint - a.triggerPoint\n  }\n\n  var groups = {\n    vertical: {},\n    horizontal: {}\n  }\n\n  return class Group {\n    constructor ({ axis, name }) {\n      this.name = name\n      this.axis = axis\n      this.id = `${name}-${axis}`\n      this.waypoints = []\n      this.clearTriggerQueues()\n      groups[axis][name] = this\n    }\n\n    add (waypoint) {\n      this.waypoints.push(waypoint)\n    }\n\n    remove (waypoint) {\n      var index = this.waypoints.indexOf(waypoint)\n      if (index > -1) {\n        this.waypoints.splice(index, 1)\n      }\n    }\n\n    clearTriggerQueues () {\n      this.triggerQueues = {\n        up: [],\n        down: [],\n        left: [],\n        right: []\n      }\n    }\n\n    queueTrigger (waypoint, direction) {\n      this.triggerQueues[direction].push(waypoint)\n    }\n\n    flushTriggers () {\n      for (var direction in this.triggerQueues) {\n        let waypoints = this.triggerQueues[direction]\n        let reverse = direction === 'up' || direction === 'left'\n        waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)\n        waypoints.forEach(function (waypoint, i) {\n          if (waypoint.continuous || i === waypoints.length - 1) {\n            waypoint.trigger(direction)\n          }\n        })\n      }\n      this.clearTriggerQueues()\n    }\n\n    next (waypoint) {\n      this.waypoints.sort(byTriggerPoint)\n      var index = this.waypoints.indexOf(waypoint)\n      if (index === -1 || index === this.waypoints.length - 1) {\n        return null\n      }\n      return this.waypoints[index + 1]\n    }\n\n    previous (waypoint) {\n      this.waypoints.sort(byTriggerPoint)\n      var index = this.waypoints.indexOf(waypoint)\n      if (index === -1 || !index) {\n        return null\n      }\n      return this.waypoints[index - 1]\n    }\n\n    first () {\n      this.waypoints.sort(byTriggerPoint)\n      return this.waypoints[0]\n    }\n\n    last () {\n      this.waypoints.sort(byTriggerPoint)\n      return this.waypoints[this.waypoints.length - 1]\n    }\n\n    static findOrCreate (options) {\n      return groups[options.axis][options.name] || new Group(options)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/group.js","module.exports = function (DOM, Context, Group) {\n  var keyCounter = 0\n  var allWaypoints = {}\n  var axialDirections = {\n    horizontal: {\n      backward: 'left',\n      forward: 'right'\n    },\n    vertical: {\n      backward: 'up',\n      forward: 'down'\n    }\n  }\n\n  return class Waypoint {\n    constructor (options) {\n      if (!options) {\n        throw new Error('No options passed to Waypoint constructor')\n      }\n      if (!options.element) {\n        throw new Error('No element option passed to Waypoint constructor')\n      }\n      if (!options.handler) {\n        throw new Error('No handler option passed to Waypoint constructor')\n      }\n\n      options = this.mergeOptions(options)\n      this.key = `waypoint-${keyCounter}`\n      this.element = options.element\n      this.dom = new DOM(options.element)\n      this.callback = options.handler\n      this.axis = options.horizontal ? 'horizontal' : 'vertical'\n      this.enabled = options.enabled\n      this.continuous = options.continuous\n      this.offset = options.offset\n      this.triggerPoint = null\n      this.group = Group.findOrCreate({\n        name: options.group,\n        axis: this.axis\n      })\n      this.context = Context.findOrCreateByElement(options.context)\n\n      this.group.add(this)\n      this.context.add(this)\n      allWaypoints[this.key] = this\n      keyCounter += 1\n    }\n\n    mergeOptions (options) {\n      if (Waypoint.offsetAliases[options.offset]) {\n        options.offset = Waypoint.offsetAliases[options.offset]\n      }\n      return {...Waypoint.defaults, ...options}\n    }\n\n    destroy () {\n      this.context.remove(this)\n      this.group.remove(this)\n      delete allWaypoints[this.key]\n    }\n\n    disable () {\n      this.enabled = false\n      return this\n    }\n\n    enable () {\n      this.context.refresh()\n      this.enabled = true\n      return this\n    }\n\n    next () {\n      return this.group.next(this)\n    }\n\n    previous () {\n      return this.group.previous(this)\n    }\n\n    trigger (direction) {\n      if (this.enabled) {\n        this.callback.call(this, direction)\n      }\n    }\n\n    shouldScrollTrigger (oldScroll, newScroll) {\n      if (this.triggerPoint === null) {\n        return null\n      }\n\n      var wasBeforeTriggerPoint = oldScroll < this.triggerPoint\n      var nowAfterTriggerPoint = newScroll >= this.triggerPoint\n\n      if (wasBeforeTriggerPoint && nowAfterTriggerPoint) {\n        return this.axialDirection('forward')\n      } else if (!wasBeforeTriggerPoint && !nowAfterTriggerPoint) {\n        return this.axialDirection('backward')\n      }\n    }\n\n    refreshTriggerPoint ({ contextDimension, contextAdjustment }) {\n      var elementOffset = 0\n      var adjustment = this.offset\n      var oldTriggerPoint = this.triggerPoint\n\n      if (!this.dom.isWindow) {\n        let offsetProp = this.axis === 'vertical' ? 'top' : 'left'\n        elementOffset = this.dom.offset()[offsetProp]\n      }\n\n      if (typeof this.offset === 'function') {\n        adjustment = this.offset.apply(this)\n      } else if (typeof this.offset === 'string') {\n        adjustment = parseFloat(adjustment)\n        if (this.offset.indexOf('%') > - 1) {\n          adjustment = Math.ceil(contextDimension * adjustment / 100)\n        }\n      }\n\n      this.triggerPoint = Math.floor(elementOffset + contextAdjustment - adjustment)\n      return this.shouldRefreshTrigger(oldTriggerPoint)\n    }\n\n    shouldRefreshTrigger(oldTriggerPoint) {\n      var scrollProp = this.axis === 'vertical' ? 'y' : 'x'\n      var contextScroll = this.context.oldScroll[scrollProp]\n      var wasBeforeScroll = oldTriggerPoint < contextScroll\n      var nowAfterScroll = this.triggerPoint >= contextScroll\n      var triggeredBackward = wasBeforeScroll && nowAfterScroll\n      var triggeredForward = !wasBeforeScroll && !nowAfterScroll\n      var freshWaypoint = oldTriggerPoint === null\n\n      if (!freshWaypoint && triggeredBackward) {\n        return this.axialDirection('backward')\n      } else if (!freshWaypoint && triggeredForward) {\n        return this.axialDirection('forward')\n      } else if (freshWaypoint && contextScroll >= this.triggerPoint) {\n        return this.axialDirection('forward')\n      }\n    }\n\n    axialDirection (direction) {\n      return axialDirections[this.axis][direction]\n    }\n\n    static invokeAll (method) {\n      for (var waypointKey in allWaypoints) {\n        allWaypoints[waypointKey][method]()\n      }\n    }\n\n    static destroyAll () {\n      this.invokeAll('destroy')\n    }\n\n    static disableAll () {\n      this.invokeAll('disable')\n    }\n\n    static enableAll () {\n      Context.refreshAll()\n      for (var waypointKey in allWaypoints) {\n        allWaypoints[waypointKey].enabled = true\n      }\n    }\n\n    static refreshAll () {\n      Context.refreshAll()\n    }\n\n    static viewportHeight () {\n      return (new DOM(window)).innerHeight()\n    }\n\n    static viewportWidth () {\n      return (new DOM(window)).innerWidth()\n    }\n\n\n    static get offsetAliases () {\n      return {\n        'bottom-in-view': function() {\n          return this.context.dom.innerHeight() - this.dom.outerHeight()\n        },\n        'right-in-view': function() {\n          return this.context.dom.innerWidth() - this.dom.outerWidth()\n        }\n      }\n    }\n\n    static get defaults () {\n      return {\n        context: window,\n        continuous: true,\n        enabled: true,\n        group: 'default',\n        horizontal: false,\n        offset: 0\n      }\n    }\n\n    static get offsetAliases () {\n      return {\n        'bottom-in-view': function () {\n          return this.context.dom.innerHeight() - this.dom.outerHeight()\n        },\n        'right-in-view': function () {\n          return this.context.dom.innerWidth() - this.dom.outerWidth()\n        }\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/waypoint.js"],"sourceRoot":""}